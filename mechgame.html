<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Platformer</title>
    <style>
        body { margin: 0; background-color: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; }
        canvas { border: 2px solid white; background-color: #87CEEB; image-rendering: -moz-crisp-edges; image-rendering: -webkit-crisp-edges; image-rendering: pixelated; image-rendering: crisp-edges; cursor: none; }
        #restartButton { position: absolute; top: 20px; left: 20px; padding: 10px 20px; font-size: 16px; background-color: #f0f0f0; border: 2px solid #333; border-radius: 5px; cursor: pointer; z-index: 10; }
        #restartButton:hover { background-color: #ddd; }
        #weaponUI { position: absolute; top: 60px; left: 20px; padding: 10px; font-size: 20px; color: white; background-color: rgba(0,0,0,0.5); border-radius: 5px; z-index: 10;}
    </style>
</head>
<body>
    <button id="restartButton">Restart</button>
    <div id="weaponUI">Weapon: Pistol</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        class InputHandler {
            constructor() { this.keys = new Set(); this.justPressed = new Set(); window.addEventListener('keydown', e => { const key = e.key.toLowerCase(); if (!this.keys.has(key)) this.justPressed.add(key); this.keys.add(key); }); window.addEventListener('keyup', e => this.keys.delete(e.key.toLowerCase())); }
            isKeyPressed(key) { return this.keys.has(key.toLowerCase()); }
            wasKeyJustPressed(key) { return this.justPressed.has(key.toLowerCase()); }
            clearJustPressed() { this.justPressed.clear(); }
        }

        class Weapon {
            constructor(name, type, damage, cooldown, pellets = 1, spread = 0) {
                this.name = name; this.type = type; // "ranged" or "melee"
                this.damage = damage; this.cooldown = cooldown;
                this.pellets = pellets; // For shotguns
                this.spread = spread; // Angle in radians
            }
        }

        class Projectile {
            constructor(x, y, targetX, targetY, firedBy, damage = 1, angleOffset = 0) {
                this.x = x; this.y = y; this.width = damage > 1 ? 6 : 4; this.height = this.width;
                this.speed = 25; this.active = true; this.firedBy = firedBy; this.damage = damage;
                const angle = Math.atan2(targetY - y, targetX - x) + angleOffset;
                this.velocityX = Math.cos(angle) * this.speed; this.velocityY = Math.sin(angle) * this.speed;
            }
            update(world, entities) {
                if (!this.active) return;
                this.x += this.velocityX; this.y += this.velocityY;
                if (this.x < 0 || this.x > world.width * world.TILE_SIZE || this.y < 0 || this.y > world.height * world.TILE_SIZE) { this.active = false; return; }
                const gridX = Math.floor(this.x / world.TILE_SIZE), gridY = Math.floor(this.y / world.TILE_SIZE);
                if (world.getTile(gridX, gridY)) { world.damageTile(gridX, gridY, this.damage); this.active = false; return; }
                for (const entity of entities) {
                    if (entity.health > 0 && this.firedBy.occupant !== entity && this.firedBy !== entity && this.x > entity.x && this.x < entity.x + entity.width && this.y > entity.y && this.y < entity.y + entity.height) {
                        entity.damage(this.damage); this.active = false; return;
                    }
                }
            }
            draw(ctx) { if (!this.active) return; ctx.fillStyle = this.damage > 2 ? 'orange' : 'yellow'; ctx.beginPath(); ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2); ctx.fill(); }
        }
        
        class PhysicsEntity {
            constructor(x, y, TILE_SIZE) { this.x = x; this.y = y; this.TILE_SIZE = TILE_SIZE; this.velocityX = 0; this.velocityY = 0; this.isOnGround = false; this.gravity = 0.6; this.health = 1; this.maxHealth = 1; }
            damage(amount) { this.health = Math.max(0, this.health - amount); }
            applyPhysics(world) { this.velocityY += this.gravity; this.x += this.velocityX; this.handleCollision(world, 'horizontal'); this.y += this.velocityY; this.handleCollision(world, 'vertical'); }
            handleCollision(world, direction) {
                const left = this.x, right = this.x + this.width, top = this.y, bottom = this.y + this.height;
                if (direction === 'horizontal') {
                    for (let y = Math.floor(top / this.TILE_SIZE); y <= Math.floor((bottom - 1) / this.TILE_SIZE); y++) {
                        if (this.velocityX < 0 && world.getTile(Math.floor(left / this.TILE_SIZE), y)) { this.x = (Math.floor(left / this.TILE_SIZE) + 1) * this.TILE_SIZE; this.velocityX = 0; break; }
                        if (this.velocityX > 0 && world.getTile(Math.floor(right / this.TILE_SIZE), y)) { this.x = Math.floor(right / this.TILE_SIZE) * this.TILE_SIZE - this.width; this.velocityX = 0; break; }
                    }
                }
                if (direction === 'vertical') {
                    this.isOnGround = false;
                    for (let x = Math.floor(left / this.TILE_SIZE); x <= Math.floor((right - 1) / this.TILE_SIZE); x++) {
                        if (this.velocityY > 0 && world.getTile(x, Math.floor(bottom / this.TILE_SIZE))) { this.y = Math.floor(bottom / this.TILE_SIZE) * this.TILE_SIZE - this.height; this.velocityY = 0; this.isOnGround = true; break; }
                        if (this.velocityY < 0 && world.getTile(x, Math.floor(top / this.TILE_SIZE))) { this.y = (Math.floor(top / this.TILE_SIZE) + 1) * this.TILE_SIZE; this.velocityY = 0; break; }
                    }
                }
            }
            drawHealthBar(ctx) {
                if (this.health > 0 && this.health < this.maxHealth) {
                    const barX = this.x, barY = this.y - 10, barWidth = this.width, barHeight = 5;
                    ctx.fillStyle = '#333'; ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = 'green'; ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
        }

        class Player extends PhysicsEntity {
            constructor(x, y, TILE_SIZE, color = 'red', isDummy = false) {
                super(x, y, TILE_SIZE);
                this.width = TILE_SIZE * 2; this.height = TILE_SIZE * 4; this.baseColor = color; this.color = color;
                this.isDummy = isDummy; this.maxHealth = 10; this.health = this.maxHealth;
                this.speed = isDummy ? 2.5 : 4; this.jumpStrength = 12;
                this.isInVehicle = false;
                
                // Weapon Inventory
                this.weapons = [
                    new Weapon("Pistol", "ranged", 1, 15),
                    new Weapon("Shotgun", "ranged", 2, 40, 3, 0.2), // 3 pellets, 0.2 radian spread
                    new Weapon("Fist", "melee", 2, 20)
                ];
                this.currentWeaponIndex = 0;

                // AI properties
                this.meleeRange = this.isDummy ? this.width * 0.8 : 40; // Player fist has short range
                this.meleeDamage = 2; this.meleeCooldown = 60; this.meleeTimer = 0;
            }
            getCurrentWeapon() { return this.weapons[this.currentWeaponIndex]; }
            cycleWeapon(direction) {
                this.currentWeaponIndex = (this.currentWeaponIndex + direction + this.weapons.length) % this.weapons.length;
            }
            handlePlayerInput(input) {
                if (input.isKeyPressed('a') || input.isKeyPressed('arrowleft')) this.velocityX = -this.speed;
                else if (input.isKeyPressed('d') || input.isKeyPressed('arrowright')) this.velocityX = this.speed;
                else this.velocityX = 0;
                if ((input.isKeyPressed('w') || input.isKeyPressed('arrowup') || input.isKeyPressed(' ')) && this.isOnGround) { this.velocityY = -this.jumpStrength; this.isOnGround = false; }
            }
            handleAI(targetEntity) {
                if (!targetEntity || targetEntity.health <= 0) { this.velocityX = 0; return; }
                if (this.meleeTimer > 0) this.meleeTimer--;
                const distanceX = (targetEntity.x + targetEntity.width / 2) - (this.x + this.width / 2);
                if (Math.abs(distanceX) < this.meleeRange && Math.abs(targetEntity.y - this.y) < this.height && this.isOnGround) {
                    this.velocityX = 0; if (this.meleeTimer <= 0) this.performMelee(targetEntity);
                } else { this.velocityX = Math.sign(distanceX) * this.speed; }
            }
            performMelee(target) { this.meleeTimer = this.meleeCooldown; target.damage(this.meleeDamage); this.color = 'white'; setTimeout(() => this.color = this.baseColor, 100); }
            update(input, world, targetEntity) {
                if (this.health <= 0) { this.velocityX = 0; this.applyPhysics(world); return; }
                if (this.isInVehicle) return;
                if (this.isDummy) this.handleAI(targetEntity); else this.handlePlayerInput(input);
                this.applyPhysics(world);
            }
            draw(ctx) { if (this.isInVehicle) return; ctx.fillStyle = this.health > 0 ? this.color : '#555'; ctx.fillRect(this.x, this.y, this.width, this.height); this.drawHealthBar(ctx); }
        }

        class Vehicle extends PhysicsEntity {
            constructor(x, y, TILE_SIZE) {
                super(x, y, TILE_SIZE);
                this.width = TILE_SIZE * 6; this.height = TILE_SIZE * 5; this.color = '#6c757d';
                this.speed = 2.5; this.jumpStrength = 13;
                this.maxHealth = 50; this.health = this.maxHealth;
                this.occupant = null;
                // Vehicle has its own powerful weapon
                this.weapon = new Weapon("Cannon", "ranged", 3, 8);
            }
            handleInput(input) {
                if (input.isKeyPressed('a') || input.isKeyPressed('arrowleft')) this.velocityX = -this.speed;
                else if (input.isKeyPressed('d') || input.isKeyPressed('arrowright')) this.velocityX = this.speed;
                else this.velocityX = 0;
                if ((input.isKeyPressed('w') || input.isKeyPressed('arrowup') || input.isKeyPressed(' ')) && this.isOnGround) { this.velocityY = -this.jumpStrength; this.isOnGround = false; }
            }
            update(input, world) {
                if (this.health <= 0) { this.eject(); this.velocityX = 0; } 
                else if (this.occupant) this.handleInput(input); 
                else this.velocityX = 0;
                this.applyPhysics(world);
            }
            eject() {
                if (!this.occupant) return;
                const p = this.occupant; p.isInVehicle = false;
                p.x = this.x + this.width / 2 - p.width / 2; p.y = this.y - p.height;
                p.velocityY = -5; this.occupant = null;
            }
            draw(ctx) { ctx.fillStyle = this.health > 0 ? this.color : '#343a40'; ctx.fillRect(this.x, this.y, this.width, this.height); this.drawHealthBar(ctx); }
        }

        class World {
            constructor(w, h, TILE_SIZE) { this.width = w; this.height = h; this.TILE_SIZE = TILE_SIZE; this.grid = []; this.BLOCK_MAX_HEALTH = 12; this.generate(); }
            generate() {
                for (let y = 0; y < this.height; y++) { this.grid[y] = []; for (let x = 0; x < this.width; x++) { if (y > this.height * 0.6) { let type = (y < this.height * 0.6 + 6) ? 'grass' : 'dirt'; this.grid[y][x] = { type, health: this.BLOCK_MAX_HEALTH }; } else this.grid[y][x] = null; } }
                const groundY = Math.floor(this.height * 0.6) + 1, h = 10, w = 15, buildingX = this.width - w - 5, buildingY = groundY - h;
                for (let y = buildingY; y < groundY; y++) { for (let x = buildingX; x < buildingX + w; x++) {
                    const isWall = x === buildingX || x === buildingX + w - 1, isRoof = y === buildingY; this.grid[y][x] = null;
                    if (isWall || isRoof) { const isDoorway = !isRoof && x === buildingX && y > buildingY + h - 4; if (!isDoorway) this.grid[y][x] = { type: 'dirt', health: this.BLOCK_MAX_HEALTH * 2 }; }
                } }
            }
            getTile(x, y) { if (x >= 0 && x < this.width && y >= 0 && y < this.height) return this.grid[y][x]; return null; }
            damageTile(x, y, dmg = 1) { const t = this.getTile(x, y); if (t) { t.health -= dmg; if (t.health <= 0) this.grid[y][x] = null; } }
            draw(ctx) { for (let y = 0; y < this.height; y++) { for (let x = 0; x < this.width; x++) { const t = this.getTile(x, y); if (t) { switch (t.type) { case 'dirt': ctx.fillStyle = '#966A4A'; break; case 'grass': ctx.fillStyle = '#6A9E49'; break; } ctx.globalAlpha = t.health / this.BLOCK_MAX_HEALTH; ctx.fillRect(x * this.TILE_SIZE, y * this.TILE_SIZE, this.TILE_SIZE, this.TILE_SIZE); ctx.globalAlpha = 1.0; } } } }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
            const restartButton = document.getElementById('restartButton'), weaponUI = document.getElementById('weaponUI');
            const TILE_SIZE = 16, WORLD_WIDTH_TILES = 100, WORLD_HEIGHT_TILES = 60;
            canvas.width = 1280; canvas.height = 720;
            let input, world, player, dummyPlayer, vehicle, allEntities, projectiles, mousePos, isMouseDown, shootTimer;

            function initializeGame() {
                input = new InputHandler(); world = new World(WORLD_WIDTH_TILES, WORLD_HEIGHT_TILES, TILE_SIZE);
                player = new Player(100, 100, TILE_SIZE, 'red', false);
                const dummySpawnX = (WORLD_WIDTH_TILES - 10) * TILE_SIZE, dummySpawnY = (WORLD_HEIGHT_TILES * 0.6 - 3) * TILE_SIZE;
                dummyPlayer = new Player(dummySpawnX, dummySpawnY, TILE_SIZE, 'blue', true);
                vehicle = new Vehicle(250, 300, TILE_SIZE);
                allEntities = [player, dummyPlayer, vehicle];
                projectiles = []; mousePos = { x: 0, y: 0 }; isMouseDown = false; shootTimer = 0;
                console.log("Game (re)started with Weapon Inventory!");
            }
            restartButton.addEventListener('click', initializeGame);
            canvas.addEventListener('mousedown', () => isMouseDown = true); canvas.addEventListener('mouseup', () => isMouseDown = false);
            canvas.addEventListener('mousemove', (e) => { const r = canvas.getBoundingClientRect(); mousePos.x = e.clientX - r.left; mousePos.y = e.clientY - r.top; });
            
            function handleWeaponSwitch() {
                if (player.isInVehicle) return;
                if (input.wasKeyJustPressed('q')) player.cycleWeapon(-1);
                if (input.wasKeyJustPressed('e')) player.cycleWeapon(1);
            }
            function handleVehicleEntry() {
                if (input.wasKeyJustPressed('c') && player.health > 0) {
                    if (player.isInVehicle) { vehicle.eject(); } 
                    else if (vehicle.health > 0 && !vehicle.occupant) {
                        if (Math.hypot((player.x + player.width / 2) - (vehicle.x + vehicle.width / 2), (player.y + player.height / 2) - (vehicle.y + vehicle.height / 2)) < vehicle.width / 2) {
                            player.isInVehicle = true; vehicle.occupant = player;
                        }
                    }
                }
            }
            function drawCrosshair(ctx) { ctx.strokeStyle = 'white'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(mousePos.x - 10, mousePos.y); ctx.lineTo(mousePos.x + 10, mousePos.y); ctx.moveTo(mousePos.x, mousePos.y - 10); ctx.lineTo(mousePos.x, mousePos.y + 10); ctx.stroke(); }
            function updateUI() { weaponUI.textContent = "Weapon: " + (player.isInVehicle ? "Cannon" : player.getCurrentWeapon().name); }

            function gameLoop() {
                if (shootTimer > 0) shootTimer--;
                if (isMouseDown && shootTimer <= 0) {
                    const shooter = player.isInVehicle ? vehicle : player;
                    const weapon = player.isInVehicle ? vehicle.weapon : shooter.getCurrentWeapon();
                    if (shooter.health > 0) {
                        if (weapon.type === "ranged") {
                            for (let i = 0; i < weapon.pellets; i++) {
                                const angleOffset = (Math.random() - 0.5) * weapon.spread;
                                projectiles.push(new Projectile(shooter.x + shooter.width / 2, shooter.y + shooter.height / 2, mousePos.x, mousePos.y, shooter, weapon.damage, angleOffset));
                            }
                        } else { // Melee attack
                            for (const entity of allEntities) {
                                if (entity !== shooter && entity.health > 0 && Math.hypot((shooter.x + shooter.width/2) - (entity.x + entity.width/2), (shooter.y + shooter.height/2) - (entity.y + entity.height/2)) < shooter.meleeRange) {
                                    entity.damage(weapon.damage);
                                }
                            }
                        }
                        shootTimer = weapon.cooldown;
                    }
                }
                
                handleWeaponSwitch(); handleVehicleEntry();
                const targetEntity = player.isInVehicle ? vehicle : player;
                player.update(input, world, targetEntity);
                dummyPlayer.update(input, world, targetEntity);
                vehicle.update(input, world);
                projectiles.forEach(p => p.update(world, allEntities));
                projectiles = projectiles.filter(p => p.active);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                world.draw(ctx); allEntities.forEach(e => e.draw(ctx));
                projectiles.forEach(p => p.draw(ctx)); drawCrosshair(ctx); updateUI();
                input.clearJustPressed();
                requestAnimationFrame(gameLoop);
            }
            initializeGame(); requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
